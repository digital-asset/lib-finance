-- Copyright (c) 2019, Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

daml 1.2
module Test.Finance.Market.Asset where

import DA.Action
import DA.Next.Map as Map
import DA.Next.Set as Set
import DA.Text

import DA.Finance.Asset
import DA.Finance.Asset.Settlement
import DA.Finance.Asset.Lifecycle
import DA.Finance.Types

import Test.Finance.Market.Party
import Test.Finance.Types
import Test.Finance.Utils

data AssetDeposits = AssetDeposits
  with
    assetDepositMap : Map Text (ContractId AssetDeposit)
    assetSettlementMap : Map Text (ContractId AssetSettlementRule)
    assetLifecycleMap : Map Text (ContractId AssetLifecycleRule)
  deriving (Eq, Show)

data AssetDepositItem = AssetDepositItem
  with
    assetDeposits : [(Text, ContractId AssetDeposit)]
    assetSettlement : (Text, ContractId AssetSettlementRule)
    assetLifecycle : (Text, ContractId AssetLifecycleRule)
  deriving (Eq, Show)

-- | The asset info used to set up the market
data AssetInfo = AssetInfo
  with
    provider : Party
    owner : Party
    assetData : [(Text, Decimal)]

-- | Add AssetDepositItem to AssetDeposits
add : AssetDeposits -> AssetDepositItem -> AssetDeposits
add assets AssetDepositItem{..} =
  let assetDepositMap = foldl (\assets (k, v) -> Map.insert k v assets) assets.assetDepositMap assetDeposits
      assetSettlementMap = Map.insert (fst assetSettlement) (snd assetSettlement) assets.assetSettlementMap
      assetLifecycleMap = Map.insert (fst assetLifecycle) (snd assetLifecycle) assets.assetLifecycleMap
  in AssetDeposits with ..

-- | Helper template to create asset deposits in an account together
-- with corresponding  AssetSettlement and AssetLifecycle contracts.
template AssetProposal
  with
    proposer : Party
      -- ^ The proposing party.
    account : Account
      -- ^ The account being used.
    assets : [Asset]
      -- ^ The assets being used.
    ctrls : Set Party
      -- ^ The controllers of the AssetSettlement_Credit choice.
  where
    signatory proposer

    let ctrl = if Set.delete proposer account.id.signatories == Set.empty
               then proposer
               else setFst $ Set.delete proposer account.id.signatories

    controller ctrl can
      -- ^ Depending on the trust model the ctrl is the same
      -- party than the proposer or a different one.
      Accept : AssetDepositItem
        do
          let observers = Set.empty
          let label = account.id.label

          let assetLabel asset = intercalate ":" [label, asset.id.label, show asset.id.version, show asset.quantity]

          assetSettlement <- (,) label <$> create AssetSettlementRule with ..
          assetLifecycle <- (,) label <$> create AssetLifecycleRule with ..
          assetDeposits <- mapA
                            (\asset -> (,) (assetLabel asset) <$> create AssetDeposit with ..)
                            assets
          
          return AssetDepositItem with ..

assetSetup : Parties -> TrustModel -> [AssetInfo] -> Scenario AssetDeposits
assetSetup p@Parties{..} trustModel assetInfo = do

  -- Init signatories according to trust model
  let initSignatories party1 party2 =
        case trustModel of
          TrustModel_Bilateral -> Set.fromList [party1, party2]
          TrustModel_Unilateral -> Set.singleton party1
          TrustModel_Agent -> Set.singleton agent

  -- Init asset backed by Reuters with version 0
  let initAsset label quantity =
        Asset with
          id = Id with signatories = Set.singleton reuters, label, version = 0
          quantity

  -- Process a single AssetInfo and add it to the AssetDeposits
  let process AssetInfo{..} assetDeposits = do
        let label = partyToText owner <> "@" <> partyToText provider
        let sigs = initSignatories provider owner
        let id = Id with signatories = sigs, label, version = 0
        let account = Account with ..
        let assets = map (uncurry initAsset) assetData
        let ctrls = Set.fromList $ map (.owner) assetInfo

        propCid <- submit (setFst sigs) do create AssetProposal with proposer = (setFst sigs), ..
        add assetDeposits <$> submit (setSndOrFirst sigs) do exercise propCid Accept

  let empty = AssetDeposits with assetDepositMap = Map.empty, assetSettlementMap = Map.empty, assetLifecycleMap = Map.empty
  foldrA process empty assetInfo
