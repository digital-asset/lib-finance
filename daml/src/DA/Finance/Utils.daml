-- Copyright (c) 2019, Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0
{-# LANGUAGE FlexibleContexts #-}

daml 1.2
module DA.Finance.Utils where

import DA.Date
import DA.Next.Map as M
import DA.Optional
import DA.Finance.Types

infixl 1 &
-- | `&` is a reverse application operator. This provides notational convenience.
-- Its precedence is one higher than that of the forward application operator `$`,
-- which allows `&` to be nested in `$`.
(&) : a -> (a -> b) -> b
x & f = f x

-- | Fetches a contract, archives it and returns its value.
fetchAndArchive : Template a => ContractId a -> Update a
fetchAndArchive cid = do
  c <- fetch cid
  archive cid
  return c

-- | Checks that the ledger time is on or after the provided date.
assertOnOrAfterDateMsg : (CanAbort m, HasTime m) => Text -> Date -> m ()
assertOnOrAfterDateMsg msg date = do
  now <- getTime
  assertMsg msg $ date <= toDateUTC now

-- | Replaces the first element of a list for which the provided function returns Some x.
mapOnce : (a -> Optional a) -> [a] -> [a]
mapOnce _ []     = []
mapOnce f (x::xs) = case f x of
        None   -> x :: mapOnce f xs
        Some y -> y :: xs

-- | Like zip but fails if the list lengths don't match
zipChecked : [a] -> [b] -> [(a, b)]
zipChecked xs ys
    | length xs /= length ys  = error "zipChecked: length mismatch"
    | otherwise               = zip xs ys

-- | Return all keys of the map in ascending order.
keys : (MapKey k) => Map k v -> [k]
keys m = map fst $ toList m

-- | Return all elements of the map in the ascending order of their keys.
elems : (MapKey k) => Map k v -> [v]
elems m = map snd $ toList m

infixl 9 !
-- | Find the value at a key. Calls error when the element can not be found.
(!) : (MapKey k) => Map k v -> k -> v
(!) m x = fromSome $ M.lookup x m

-- | Like map insert but takes an Action as value and returns the modified map as action.
insertA : (Action m, MapKey k) => Map k v -> k -> m v -> m (Map k v)
insertA m k mv = do v <- mv; return $ M.insert k v m

increaseVersion : Id -> Id
increaseVersion id = id with version = id.version + 1
