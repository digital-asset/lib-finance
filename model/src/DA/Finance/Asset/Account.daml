module DA.Finance.Asset.Account where

import DA.Optional (isNone)
import DA.Set
import DA.Finance.Types (Account, Asset, Lock, Id)
import DA.Finance.Asset (AssetDeposit(..), AssetDeposit_SetObservers(..))
import DA.Finance.Utils (fetchAndArchive)

template TransferInstructions
  with
    submitter : Party
    -- ^ Party submitting this transaction. Can be the sending account owner or a third party
    -- such as a service provider.
    sendingAccount : Account
    -- ^ The account which is sending the asset.
    depositCid : ContractId AssetDeposit
    -- ^ The deposit containing the asset.
    receivingAccount : Account
    -- ^ The account receiving the asset.
  where
    signatory submitter, sendingAccount.owner, receivingAccount.owner

template AccountRule
  with
    account : Account
      -- ^ The account for which the rule can be used.
    nominees : Set Party
      -- ^ Parties which may act on this account on behalf of the owner
    observers : Set Party
      -- ^ Set of parties that will be added as observers
      -- when an asset is credited, i.e. an asset deposit is
      -- created.
  where
    signatory account.id.signatories
    observer nominees `union` observers
    ensure not $ account.owner `member` nominees

    key account.id : Id
    maintainer key.signatories

    let checkNominee : CanAbort Update => Party -> AccountRule -> Update ()
        checkNominee = \nominee rule -> assertMsg ("Nominee " <> show nominee <> " is not authorized on this account.") $ nominee `member` rule.nominees
        checkDepositAccount : CanAbort Update => AssetDeposit -> AccountRule -> Update ()
        checkDepositAccount = \deposit rule -> assertMsg "Deposit account owner does not match" $ deposit.account.owner == rule.account.owner
        checkDepositLock : CanAbort Update => AssetDeposit -> Update ()
        checkDepositLock = \deposit -> assertMsg "AssetDeposit is locked." $ isNone deposit.lock
        checkTransferAccounts : CanAbort Update => Account -> Account -> Update ()
        checkTransferAccounts = \fromAccount toAccount -> assertMsg "Account signatories do not facilitate this transfer request"
          $ (toAccount.owner `delete` toAccount.id.signatories) `difference` (fromAccount.owner `delete` fromAccount.id.signatories) == empty

    nonconsuming choice DirectTransfer : ContractId AssetDeposit
      -- ^ A peer-to-peer transfer of an asset deposit directly to another party.
      with
        depositCid : ContractId AssetDeposit
        toAccount : Account
      controller account.owner, toAccount.owner, toAccount.id.signatories
      do
        deposit <- fetchAndArchive depositCid
        (_, toAccountRule) <- fetchByKey @AccountRule toAccount.id
        checkDepositAccount deposit this *> checkDepositLock deposit

        create AssetDeposit with account = toAccount; asset = deposit.asset; lock = None; observers = toAccountRule.observers

    nonconsuming choice Transfer : ContractId AssetDeposit
      -- ^ Tranfer an asset deposit to another party by a shared intermediary.
      with
        depositCid : ContractId AssetDeposit
        toAccount : Account
        nominee : Party
      controller account.owner, nominee, toAccount.owner
      do
        checkTransferAccounts account toAccount
        exercise self Debit with depositCid; nominee >>= \asset -> exerciseByKey @AccountRule toAccount.id Credit with asset; nominee

    nonconsuming choice InitiateTransfer : ContractId AssetDeposit
      with
        submitter : Party
        sender : Party
        receiver : Party
        transferInstructionsCid : ContractId TransferInstructions
      controller account.owner, submitter, sender, receiver
      do
        transferInstructions <- fetch transferInstructionsCid
        assertMsg "Provided parameters do not match transfer instruction"
          $ [ submitter, sender, receiver] == [ transferInstructions.submitter, transferInstructions.sendingAccount.owner, transferInstructions.receivingAccount.owner ]
        asset <- exercise self Debit2 with depositCid = transferInstructions.depositCid

        exerciseByKey @AccountRule transferInstructions.receivingAccount.id ReceiveTransfer with submitter; sender; receiver; transferInstructionsCid; asset

    nonconsuming choice ReceiveTransfer : ContractId AssetDeposit
      with
        submitter : Party
        sender : Party
        receiver : Party
        transferInstructionsCid : ContractId TransferInstructions
        asset : Asset
      controller account.owner, submitter, sender, receiver
      do
        transferInstructions <- fetchAndArchive transferInstructionsCid
        assertMsg "Provided parameters do not match transfer instruction"
          $ [ submitter, sender, receiver] == [ transferInstructions.submitter, transferInstructions.sendingAccount.owner, transferInstructions.receivingAccount.owner ]

        exercise self Credit2 with asset

    nonconsuming choice Credit : ContractId AssetDeposit
      -- ^ Credit an account.
      with
        asset : Asset
        nominee : Party
      controller account.owner, nominee
      do
        checkNominee nominee this

        create AssetDeposit with account; asset; lock = None; observers

    nonconsuming choice Credit2 : ContractId AssetDeposit
      -- ^ Credit an account.
      with
        asset : Asset
      controller account.owner, account.id.signatories
      do
        create AssetDeposit with account; asset; lock = None; observers

    nonconsuming choice Debit : Asset
      -- ^ Debit an account. The asset deposit to be debited is consumed in its
      -- entirety.
      with
        depositCid : ContractId AssetDeposit
        nominee : Party
      controller account.owner, nominee
      do
        checkNominee nominee this

        deposit <- fetchAndArchive depositCid
        checkDepositAccount deposit this *> checkDepositLock deposit
        pure deposit.asset

    nonconsuming choice Debit2 : Asset
      -- ^ Debit an account. The asset deposit to be debited is consumed in its
      -- entirety.
      with
        depositCid : ContractId AssetDeposit
      controller account.owner, account.id.signatories
      do
        deposit <- fetchAndArchive depositCid
        checkDepositAccount deposit this *> checkDepositLock deposit
        pure deposit.asset

    nonconsuming choice LockAssetDeposit : ContractId AssetDeposit
      -- ^ Lock an asset deposit. Locking an asset deposit will block the asset
      -- deposit from any action until the lock is released by one of the
      -- parties set on the lock.
      with
        newLock : Lock
        depositCid : ContractId AssetDeposit
        nominee : Party
      controller account.owner, nominee
      do
        checkNominee nominee this

        deposit <- fetchAndArchive depositCid
        checkDepositAccount deposit this *> checkDepositLock deposit
        create deposit with lock = Some newLock

    nonconsuming choice UnlockAssetDeposit : ContractId AssetDeposit
      -- ^ Unlock an asset deposit. Requires the signature from one of the
      -- `releasers` party set on the lock.
      with
        depositCid : ContractId AssetDeposit
        releaser : Party
      controller account.owner, releaser
      do
        deposit <- fetchAndArchive depositCid

        case deposit.lock of
          None -> abort "Account is not locked"
          Some l -> do
            assertMsg ("Party " <> show releaser <> " does not have the authority to unlock this account.") $ releaser `member` l.releasers
            create deposit with lock = None

    choice AddNominee : ContractId AccountRule
      -- ^ Add a nominee to an account.
      with
        nominee : Party
      controller account.owner, account.id.signatories, nominee
      do
        create this with nominees = nominee `insert` nominees

    choice RemoveNominee : ContractId AccountRule
      -- ^ Remove a nominee from an account. Requires the signature of the nominee
      -- to ensure any pending transactions are completed or moved to an appropriate
      -- state.
      with
        nominee : Party
      controller account.owner, account.id.signatories, nominee
      do
        create this with nominees = nominee `delete` nominees

    choice AddObserver : (ContractId AccountRule, [ContractId AssetDeposit])
      -- ^ Add an observer to an account. Requires updating the observers of asset
      -- deposits assocated to this account.
      with
        observer : Party
        depositCids : [ContractId AssetDeposit]
      controller account.owner
      do
        let newObservers = observer `insert` observers

        newDepositCids <- forA depositCids \depositCid -> exercise depositCid AssetDeposit_SetObservers with newObservers
        accountRule <- create this with observers = newObservers
        pure (accountRule, newDepositCids)

    choice RemoveObserver : (ContractId AccountRule, [ContractId AssetDeposit])
      -- ^ Remove an observer from an account. Requires updating the observers of asset
      -- deposits assocated to this account.
      with
        observer : Party
        depositCids : [ContractId AssetDeposit]
      controller account.owner
      do
        let newObservers = observer `delete` observers

        newDepositCids <- forA depositCids \depositCid -> exercise depositCid AssetDeposit_SetObservers with newObservers
        accountRule <- create this with observers = newObservers
        pure (accountRule, newDepositCids)
