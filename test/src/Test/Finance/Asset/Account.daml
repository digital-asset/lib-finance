module Finance.Asset.Account where

import Daml.Script
import DA.Assert ((===))
import DA.Finance.Asset.Account qualified as Account
import DA.Finance.Asset
import DA.Finance.Types
import DA.Set
import DA.Optional

accountRuleLockingTest : Script ()
accountRuleLockingTest = do
  now <- getTime

  -- Create our parties
  [alice, bob, bank, exchange, issuer, auditor] <- forA ["Alice", "Bob", "Bank", "Exchange", "Issuer", "Auditor"] \party -> allocatePartyWithHint party $ PartyIdHint party

  -- Alice creates an account at the bank -> Gather Alice's and the Bank signatures and create account to simulate a real life use case
  let accountId = \party -> Id with signatories = fromList [ bank, party ]; label = partyToText party <> "@" <> partyToText bank; version = 0
      account = \party -> Account with provider = bank; owner = party; id = accountId party
      assetId = Id with signatories = fromList [ bank, issuer]; label = "btc"; version = 0
      asset = Asset with id = assetId; quantity = 1.0

  -- Create an account for Alice and Bob
  aliceAccountRuleCid <- submitMulti [ alice, bank ] [] $ createCmd Account.AccountRule with account = account alice; nominees = fromList [ exchange, bank ]; observers = empty
  bobAccountRuleCid   <- submitMulti [ bob, bank ]   [] $ createCmd Account.AccountRule with account = account bob;   nominees = fromList [ exchange, bank ]; observers = empty

  -- Alice and the Bank both attempt on their own to Credit the account
  alice `submitMustFail` exerciseCmd aliceAccountRuleCid Account.Credit with asset; nominee = alice  -- Fails as Alice is not an nominee
  bank  `submitMustFail` exerciseCmd aliceAccountRuleCid Account.Credit with asset; nominee = bank   -- Fails due to missing auth from Alice

  -- Credit the account with both the signature of alice and the bank
  depositCid <- submitMulti [ alice, bank ] [] $ exerciseCmd aliceAccountRuleCid Account.Credit with asset; nominee = bank

  -- Lock Alice's deposit as she has submitted a trade on an exchange using this asset deposit as collateral
  let relatingId = Id with signatories = fromList [ alice, exchange ]; label = "Exchange order - #123456"; version = 0
      newLock = Lock with by = bank; at = now; reason = "Collateral for exchange order"; relatingId; releasers = fromList [ exchange ]
  depositCid <- submitMulti [ alice, exchange ] [] $ exerciseCmd aliceAccountRuleCid Account.LockAssetDeposit with newLock; depositCid; nominee = exchange
  submitMultiMustFail [ alice, exchange ] [] $ exerciseCmd aliceAccountRuleCid Account.LockAssetDeposit with newLock; depositCid; nominee = exchange -- Locking an already locked deposit fails
  Some deposit <- queryContractId alice depositCid
  isSome deposit.lock === True

  -- Alice attempts some actions on her deposit which fail due to the account being locked
  submitMultiMustFail [alice, bank]      [] $ exerciseCmd aliceAccountRuleCid Account.Debit    with depositCid; nominee = bank
  submitMultiMustFail [alice, bank, bob] [] $ exerciseCmd aliceAccountRuleCid Account.Transfer with depositCid; toAccount = account bob; nominee = bank
  submitMultiMustFail [alice]            [] $ exerciseCmd depositCid AssetDeposit_Split with quantities = [1.0]
  submitMultiMustFail [alice]            [] $ exerciseCmd depositCid AssetDeposit_Merge with depositCids = [depositCid]

  -- The order is cancelled by the exchange and the funds are returned to Alice
  depositCid <- submitMulti [ alice, exchange ] [] $ exerciseCmd aliceAccountRuleCid Account.UnlockAssetDeposit with depositCid; releaser = exchange
  Some deposit <- queryContractId alice depositCid
  isSome deposit.lock === False

  -- Alice transfers the deposit to bob
  depositCid <- submitMulti [alice, bank, bob] [] $ exerciseCmd aliceAccountRuleCid Account.Transfer with depositCid; toAccount = account bob; nominee = bank
  None <- queryContractId alice depositCid
  Some deposit <- queryContractId bob depositCid
  isSome deposit.lock === False

  -- Alice wants to remove the exchange as a nominee. The exchange checks for pending orders and provides their signature to remove them as an nominee on the account
  aliceAccountRuleCid <- submitMulti [alice, exchange] [] $ exerciseCmd aliceAccountRuleCid Account.RemoveNominee with nominee = exchange
  Some aliceAccountRule <- queryContractId alice aliceAccountRuleCid
  aliceAccountRule.nominees === fromList [ bank ]

  -- Alice attempts to remove the bank as a nominees without their signature
  submitMultiMustFail [alice] [] $ exerciseCmd aliceAccountRuleCid Account.RemoveNominee with nominee = bank

  -- Alice attemps to add the exchange back as a nominee without their signature
  submitMultiMustFail [alice] [] $ exerciseCmd aliceAccountRuleCid Account.AddNominee with nominee = exchange

  -- Alice formally requests the exchange for services and the exchange provides their signature
  aliceAccountRuleCid <- submitMulti [alice, exchange] [] $ exerciseCmd aliceAccountRuleCid Account.AddNominee with nominee = exchange
  Some aliceAccountRule <- queryContractId alice aliceAccountRuleCid
  aliceAccountRule.nominees === fromList [ bank, exchange ]

  -- Bob decides to do a direct transfer of his asset to Alice but is missing Alice's approval
  submitMultiMustFail [ bob ] [] $ exerciseCmd bobAccountRuleCid Account.DirectTransfer with depositCid; toAccount = account alice

  -- Bob gets Alice's approval and executes the direct transfer of the asset to Alice
  depositCid <- submitMulti [ bob, alice ] [] $ exerciseCmd bobAccountRuleCid Account.DirectTransfer with depositCid; toAccount = account alice
  Some deposit <- queryContractId alice depositCid
  deposit.account === account alice

  -- Create an account for Alice and Bob where they are the only signatories of the account
  let singlePartyBackedAccount = \party -> Account with provider = bank; owner = party; id = Id with signatories = fromList [ party ]; label = partyToText party <> "@" <> partyToText party; version = 0
  alice `submitMustFail` createCmd Account.AccountRule with account = singlePartyBackedAccount alice; nominees = fromList [ exchange, bank, alice ]; observers = empty -- Alice cannot set herself as a nominee
  aliceAccountRuleCid <- alice `submit` createCmd Account.AccountRule with account = singlePartyBackedAccount alice; nominees = fromList [ exchange, bank ]; observers = empty

  -- Alice attemps to credit her account
  alice `submitMustFail` exerciseCmd aliceAccountRuleCid Account.Credit with asset; nominee = alice -- Fails as alice is not a nominee on the account
  depositCid <- submitMulti [ alice, bank ] [] $ exerciseCmd aliceAccountRuleCid Account.Credit with asset; nominee = bank

  -- Alice makes a peer to peer and an intermediary transfer to Bob
  submitMultiMustFail [ alice, bob ] [] $ exerciseCmd aliceAccountRuleCid Account.DirectTransfer with depositCid; toAccount = account bob -- Fails due to account signatories differences
  submitMultiMustFail [ alice, bob, bank ] [] $ exerciseCmd aliceAccountRuleCid Account.Transfer with depositCid; toAccount = account bob; nominee = bank -- Fails due to account signatories differences

  pure ()