module Finance.Asset.Account where

import Daml.Script
import DA.Assert ((===))
import DA.Finance.Asset.Account qualified as Account
import DA.Finance.Asset
import DA.Finance.Types
import DA.Set
import DA.Optional

accountRuleLockingTest : Script ()
accountRuleLockingTest = do
  -- Create our parties
  [alice, bob, bank, exchange, issuer, auditor] <- forA ["Alice", "Bob", "Bank", "Exchange", "Issuer", "Auditor"] \party -> allocatePartyWithHint party $ PartyIdHint party

  -- Alice creates an account at the bank -> Gather Alice's and the Bank signatures and create account to simulate a real life use case
  let accountId = \party -> Id with signatories = fromList [ bank, party ]; label = partyToText party <> "@" <> partyToText bank; version = 0
      account = \party -> Account with provider = bank; owner = party; id = accountId party
      assetId = Id with signatories = fromList [ bank, issuer]; label = "btc"; version = 0
      asset = Asset with id = assetId; quantity = 1.0

  -- Create an account for Alice and Bob
  aliceAccountRuleCid <- submitMulti [ alice, bank ] [] $ createCmd Account.AccountRule with account = account alice; nominees = fromList [ exchange, bank ]; lock = None; observers = empty
  bobAccountRuleCid   <- submitMulti [ bob, bank ]   [] $ createCmd Account.AccountRule with account = account bob;   nominees = fromList [ exchange, bank ]; lock = None; observers = empty

  -- Alice and the Bank both attempt on their own to Credit the account
  alice `submitMustFail` exerciseCmd aliceAccountRuleCid Account.Credit with asset; nominee = alice  -- Fails as Alice is not an nominee
  bank  `submitMustFail` exerciseCmd aliceAccountRuleCid Account.Credit with asset; nominee = bank   -- Fails due to missing auth from Alice

  -- Credit the account with both the signature of alice and the bank
  depositCid <- submitMulti [ alice, bank ] [] $ exerciseCmd aliceAccountRuleCid Account.Credit with asset; nominee = bank

  -- Alice's account gets locked due to failing an external audit of her account activities
  now <- getTime
  let relatingId = Id with signatories = fromList [ bank, auditor ]; label = "Fraud case - #123456"; version = 0
      newLock = Lock with by = bank; at = now; reason = "Suspected Fraud"; relatingId; releasers = fromList [ auditor ]
  aliceAccountRuleCid <- submitMulti [alice, bank] [] $ exerciseCmd aliceAccountRuleCid Account.LockAccount with newLock; nominee = bank
  submitMultiMustFail [alice, bank] [] $ exerciseCmd aliceAccountRuleCid Account.LockAccount with newLock; nominee = bank -- Locking an already locked account fails
  Some aliceAccountRule <- queryContractId alice aliceAccountRuleCid
  isSome aliceAccountRule.lock === True

  -- Alice attempts some actions on her account which fail due to the account being locked
  submitMultiMustFail [alice, bank]      [] $ exerciseCmd aliceAccountRuleCid Account.Credit   with asset; nominee = bank
  submitMultiMustFail [alice, bank]      [] $ exerciseCmd aliceAccountRuleCid Account.Debit    with depositCid; nominee = bank
  submitMultiMustFail [alice, bank, bob] [] $ exerciseCmd aliceAccountRuleCid Account.Transfer with depositCid; toAccount = account bob; nominee = bank

  -- Alice tries to unlock her own account in various ways
  submitMultiMustFail [alice] [] $ exerciseCmd aliceAccountRuleCid Account.UnlockAccount with releaser = alice         -- Alice is not specified as a releaser in the lock
  submitMultiMustFail [alice, bank] [] $ exerciseCmd aliceAccountRuleCid Account.UnlockAccount with releaser = auditor -- Mising signature from the Auditor

  -- Auditor validates that Alice's account is ok
  aliceAccountRuleCid <- submitMulti [alice, auditor] [] $ exerciseCmd aliceAccountRuleCid Account.UnlockAccount with releaser = auditor
  Some aliceAccountRule <- queryContractId alice aliceAccountRuleCid
  isSome aliceAccountRule.lock === False

  -- Lock Alice's deposit as she has submitted a trade on an exchange using this asset deposit as collateral
  let relatingId = Id with signatories = fromList [ alice, exchange ]; label = "Exchange order - #123456"; version = 0
      newLock = Lock with by = bank; at = now; reason = "Collateral for exchange order"; relatingId; releasers = fromList [ exchange ]
  depositCid <- submitMulti [ alice, exchange ] [] $ exerciseCmd aliceAccountRuleCid Account.LockAssetDeposit with newLock; depositCid; nominee = exchange
  submitMultiMustFail [ alice, exchange ] [] $ exerciseCmd aliceAccountRuleCid Account.LockAssetDeposit with newLock; depositCid; nominee = exchange -- Locking an already locked deposit fails
  Some deposit <- queryContractId alice depositCid
  isSome deposit.lock === True

  -- Alice attempts some actions on her deposit which fail due to the account being locked
  submitMultiMustFail [alice, bank]      [] $ exerciseCmd aliceAccountRuleCid Account.Debit    with depositCid; nominee = bank
  submitMultiMustFail [alice, bank, bob] [] $ exerciseCmd aliceAccountRuleCid Account.Transfer with depositCid; toAccount = account bob; nominee = bank
  submitMultiMustFail [alice]            [] $ exerciseCmd depositCid AssetDeposit_Split with quantities = [1.0]
  submitMultiMustFail [alice]            [] $ exerciseCmd depositCid AssetDeposit_Merge with depositCids = [depositCid]

  -- The order is cancelled by the exchange and the funds are returned to Alice
  depositCid <- submitMulti [ alice, exchange ] [] $ exerciseCmd aliceAccountRuleCid Account.UnlockAssetDeposit with depositCid; releaser = exchange
  Some deposit <- queryContractId alice depositCid
  isSome deposit.lock === False

  -- Alice transfers the deposit to bob
  depositCid <- submitMulti [alice, bank, bob] [] $ exerciseCmd aliceAccountRuleCid Account.Transfer with depositCid; toAccount = account bob; nominee = bank
  None <- queryContractId alice depositCid
  Some deposit <- queryContractId bob depositCid
  isSome deposit.lock === False

  -- Alice wants to remove the exchange as a nominee. The exchange checks for pending orders and provides their signature to remove them as an nominee on the account
  aliceAccountRuleCid <- submitMulti [alice, exchange] [] $ exerciseCmd aliceAccountRuleCid Account.RemoveNominee with nominee = exchange
  Some aliceAccountRule <- queryContractId alice aliceAccountRuleCid
  aliceAccountRule.nominees === fromList [ bank ]

  -- Alice attempts to remove the bank as a nominees without their signature
  submitMultiMustFail [alice] [] $ exerciseCmd aliceAccountRuleCid Account.RemoveNominee with nominee = bank

  -- Alice attemps to add the exchange back as a nominee without their signature
  submitMultiMustFail [alice] [] $ exerciseCmd aliceAccountRuleCid Account.AddNominee with nominee = exchange

  -- Alice formally requests the exchange for services and the exchange provides their signature
  aliceAccountRuleCid <- submitMulti [alice, exchange] [] $ exerciseCmd aliceAccountRuleCid Account.AddNominee with nominee = exchange
  Some aliceAccountRule <- queryContractId alice aliceAccountRuleCid
  aliceAccountRule.nominees === fromList [ bank, exchange ]

  pure ()
